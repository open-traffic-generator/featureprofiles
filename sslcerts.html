<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head> <title>curl - SSL CA Certificates</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<link rel="stylesheet" type="text/css" href="/curl.css">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="icon" href="/logo/curl-symbol.svg" type="image/svg+xml">
<link rel="alternate" type="application/rss+xml" title="cURL Releases" href="https://github.com/curl/curl/releases.atom">
</head>
<body>
<div class="main">
<div class="menu">
<a href="/docs/" class="menuitem" title="Documentation Overview">Docs Overview</a>
<div class="dropdown">
  <a class="dropbtn" href="/docs/projdocs.html">Project</a>
  <div class="dropdown-content">
    <a href="/docs/bugbounty.html">Bug Bounty</a>
    <a href="/docs/bugs.html">Bug Report</a>
    <a href="/docs/code-of-conduct.html">Code of conduct</a>
    <a href="/docs/libs.html">Dependencies</a>
    <a href="/donation.html">Donate</a>
    <a href="/docs/faq.html">FAQ</a>
    <a href="/docs/features.html">Features</a>
    <a href="/docs/governance.html">Governance</a>
    <a href="/docs/history.html">History</a>
    <a href="/docs/install.html">Install</a>
    <a href="/docs/knownbugs.html">Known Bugs</a>
    <a href="/logo/">Logo</a>
    <a href="/docs/todo.html">TODO</a>
    <a href="/about.html">website Info</a>
  </div>
</div>
<div class="dropdown">
  <a class="dropbtn" href="/docs/protdocs.html">Protocols</a>
  <div class="dropdown-content">
    <a href="/docs/alt-svc.html">alt-svc</a>
    <a href="/docs/caextract.html">CA Extract</a>
    <a href="/docs/hsts.html">HSTS</a>
    <a href="/docs/http-cookies.html">HTTP cookies</a>
    <a href="/docs/http2.html">HTTP/2</a>
    <a href="/docs/http3.html">HTTP/3</a>
    <a href="/docs/mqtt.html">MQTT</a>
    <a href="/docs/sslcerts.html">SSL certs</a>
    <a href="/docs/ssl-compared.html">SSL libs compared</a>
    <a href="/docs/url-syntax.html">URL syntax</a>
    <a href="/docs/websocket.html">WebSocket</a>
  </div>
</div>
<div class="dropdown">
  <a class="dropbtn" href="/docs/reldocs.html">Releases</a>
  <div class="dropdown-content">
    <a href="/ch/">Changelog</a>
    <a href="/docs/security.html">curl CVEs</a>
    <a href="/docs/releases.html">Release Table</a>
    <a href="/docs/versions.html">Version Numbering</a>
    <a href="/docs/vulnerabilities.html">Vulnerabilities</a>
  </div>
</div>
<div class="dropdown">
  <a class="dropbtn" href="/docs/tooldocs.html">Tool</a>
  <div class="dropdown-content">
    <a href="/docs/comparison-table.html">Comparison Table</a>
    <a href="/docs/manpage.html">curl manpage</a>
    <a href="/docs/httpscripting.html">HTTP Scripting</a>
    <a href="/docs/mk-ca-bundle.html">mk-ca-bundle</a>
    <a href="/docs/tutorial.html">Tutorial</a>
    <a href="optionswhen.html">When options were added</a>
  </div>
</div>
<div class="dropdown">
  <a class="dropbtn" href="/docs/whodocs.html">Who and Why</a>
  <div class="dropdown-content">
    <a href="/docs/companies.html">Companies</a>
    <a href="/docs/copyright.html">Copyright</a>
    <a href="/sponsors.html">Sponsors</a>
    <a href="/docs/thanks.html">Thanks</a>
    <a href="/docs/thename.html">The name</a>
  </div>
</div>
</div>
<div class="contents">
<div class="where"><a href="/">curl</a> / <a href="/docs/">Docs</a> / <a href="/docs/protdocs.html">Protocols</a> / <b>SSL Certificates</b></div>
<div class="relatedbox">
<b>Related:</b>
<br><a href="caextract.html">CA extract</a>
</div>
<!--
Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
SPDX-License-Identifier: curl
-->
<h1 id="ssl-certificate-verification">SSL Certificate Verification</h1>
<h2 id="ssl-is-tls">SSL is TLS</h2>
<p>SSL is the old name. It is called TLS these days.</p>
<h2 id="native-ssl">Native SSL</h2>
<p>If libcurl was built with Schannel or Secure Transport support (the
native SSL libraries included in Windows and macOS), then this does not
apply to you. Scroll down for details on how the OS-native engines
handle SSL certificates. If you are not sure, then run "curl -V" and
read the results. If the version string says <code>Schannel</code> in
it, then it was built with Schannel support.</p>
<h2 id="it-is-about-trust">It is about trust</h2>
<p>This system is about trust. In your local CA certificate store you
have certs from <em>trusted</em> Certificate Authorities that you then
can use to verify that the server certificates you see are valid. They
are signed by one of the certificate authorities you trust.</p>
<p>Which certificate authorities do you trust? You can decide to trust
the same set of companies your operating system trusts, or the set one
of the known browsers trust. That is basically trust via someone else
you trust. You should just be aware that modern operating systems and
browsers are setup to trust <em>hundreds</em> of companies and in recent
years several certificate authorities have been found untrustworthy.</p>
<h2 id="certificate-verification">Certificate Verification</h2>
<p>libcurl performs peer SSL certificate verification by default. This
is done by using a CA certificate store that the SSL library can use to
make sure the peer's server certificate is valid.</p>
<p>If you communicate with HTTPS, FTPS or other TLS-using servers using
certificates in the CA store, you can be sure that the remote server
really is the one it claims to be.</p>
<p>If the remote server uses a self-signed certificate, if you do not
install a CA cert store, if the server uses a certificate signed by a CA
that is not included in the store you use or if the remote host is an
impostor impersonating your favorite site, and you want to transfer
files from this server, do one of the following:</p>
<ol type="1">
<li><p>Tell libcurl to <em>not</em> verify the peer. With libcurl you
disable this with
<code>curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, FALSE);</code></p>
<p>With the curl command line tool, you disable this with
<code>-k</code>/<code>--insecure</code>.</p></li>
<li><p>Get a CA certificate that can verify the remote server and use
the proper option to point out this CA cert for verification when
connecting. For libcurl hackers:
<code>curl_easy_setopt(curl, CURLOPT_CAINFO, cacert);</code></p>
<p>With the curl command line tool:
<code>--cacert [file]</code></p></li>
<li><p>Add the CA cert for your server to the existing default CA
certificate store. The default CA certificate store can be changed at
compile time with the following configure options:</p>
<p><code>--with-ca-bundle=FILE</code>: use the specified file as the CA
certificate store. CA certificates need to be concatenated in PEM format
into this file.</p>
<p><code>--with-ca-path=PATH</code>: use the specified path as CA
certificate store. CA certificates need to be stored as individual PEM
files in this directory. You may need to run c_rehash after adding files
there.</p>
<p>If neither of the two options is specified, configure tries to
auto-detect a setting. It's also possible to explicitly not set any
default store but rely on the built in default the crypto library may
provide instead. You can achieve that by passing both
<code>--without-ca-bundle</code> and <code>--without-ca-path</code> to
the configure script.</p>
<p>If you use Internet Explorer, this is one way to get extract the CA
cert for a particular server:</p>
<ul>
<li>View the certificate by double-clicking the padlock</li>
<li>Find out where the CA certificate is kept (Certificate&gt; Authority
Information Access&gt;URL)</li>
<li>Get a copy of the crt file using curl</li>
<li>Convert it from crt to PEM using the OpenSSL tool:
<code>openssl x509 -inform DES -in yourdownloaded.crt -out outcert.pem -text</code></li>
<li>Add the <code>outcert.pem</code> to the CA certificate store or use
it stand-alone as described below.</li>
</ul>
<p>If you use the <code>openssl</code> tool, this is one way to get
extract the CA cert for a particular server:</p>
<ul>
<li><code>openssl s_client -showcerts -servername server -connect server:443 &gt; cacert.pem</code></li>
<li>type "quit", followed by the "ENTER" key</li>
<li>The certificate has <code>BEGIN CERTIFICATE</code> and
<code>END CERTIFICATE</code> markers.</li>
<li>If you want to see the data in the certificate, you can do:
<code>openssl x509 -inform PEM -in certfile -text -out certdata</code>
where <code>certfile</code> is the cert you extracted from logfile. Look
in <code>certdata</code>.</li>
<li>If you want to trust the certificate, you can add it to your CA
certificate store or use it stand-alone as described. Just remember that
the security is no better than the way you obtained the
certificate.</li>
</ul></li>
<li><p>If you are using the curl command line tool and the TLS backend
is not Schannel then you can specify your own CA cert file by setting
the environment variable <code>CURL_CA_BUNDLE</code> to the path of your
choice.</p>
<p>If you are using the curl command line tool on Windows, curl searches
for a CA cert file named "curl-ca-bundle.crt" in these directories and
in this order:</p>
<ol type="1">
<li>application's directory</li>
<li>current working directory</li>
<li>Windows System directory (e.g. C:\Windows\System32)</li>
<li>Windows Directory (e.g. C:\Windows)</li>
<li>all directories along %PATH%</li>
</ol></li>
<li><p>Get another CA cert bundle. One option is to extract the one a
recent Firefox browser uses by running 'make ca-bundle' in the curl
build tree root, or possibly download a version that was generated this
way for you: <a href="https://curl.se/docs/caextract.html">CA
Extract</a></p></li>
</ol>
<p>Neglecting to use one of the above methods when dealing with a server
using a certificate that is not signed by one of the certificates in the
installed CA certificate store, causes SSL to report an error
(<code>certificate verify failed</code>) during the handshake and SSL
then refuses further communication with that server.</p>
<h2
id="certificate-verification-with-schannel-and-secure-transport">Certificate
Verification with Schannel and Secure Transport</h2>
<p>If libcurl was built with Schannel (Microsoft's native TLS engine) or
Secure Transport (Apple's native TLS engine) support, then libcurl still
performs peer certificate verification, but instead of using a CA cert
bundle, it uses the certificates that are built into the OS. These are
the same certificates that appear in the Internet Options control panel
(under Windows) or Keychain Access application (under macOS). Any custom
security rules for certificates are honored.</p>
<p>Schannel runs CRL checks on certificates unless peer verification is
disabled. Secure Transport on iOS runs OCSP checks on certificates
unless peer verification is disabled. Secure Transport on macOS runs
either OCSP or CRL checks on certificates if those features are enabled,
and this behavior can be adjusted in the preferences of Keychain
Access.</p>
<h2 id="https-proxy">HTTPS proxy</h2>
<p>Since version 7.52.0, curl can do HTTPS to the proxy separately from
the connection to the server. This TLS connection is handled separately
from the server connection so instead of <code>--insecure</code> and
<code>--cacert</code> to control the certificate verification, you use
<code>--proxy-insecure</code> and <code>--proxy-cacert</code>. With
these options, you make sure that the TLS connection and the trust of
the proxy can be kept totally separate from the TLS connection to the
server.</p>
</div>
</div>
</body>
</html>
